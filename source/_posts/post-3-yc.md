---
title: 原创：Git学习笔记(1) - 内部原理
mathjax: false
date: 2020-04-29 20:58:41
updated: 2020-05-01 15:09:01
categories: Git
tags:
  - Git
  - MsysGit
  - 版本控制系统
  - Windows
  - Windows PowerShell
---

本文参考了 **[Pro Git book](https://git-scm.com/book/en/v2)** 第10章 [Git Internals](https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain) 的相关内容。

---

早期的Git被设计成一个内容寻址(content-addressable)文件系统，而不是一个完整的、用户友好的版本控制系统(VCS)，换句话说，Git本质上是一个文件系统，并在此之上提供了一套面向版本控制系统的工具。

因此，Git除了包含面向最终用户的上层命令(high-level commands)，还包含了一部分用于完成底层工作的子命令，即底层命令(low-level commands)，大多数底层命令并不面向最终用户：它们更适合作为新工具的组件和自定义脚本的组成部分。

>注：关于全部的上层命令和底层命令，可以参阅[git的官方文档](https://git-scm.com/docs/git)。

<!-- more -->

当在一个目录下执行命令`git init`时，Git会在该目录下创建一个`.git`目录，该目录包含几乎所有Git存储和操作的东西。如果你想备份或者复制一个Git版本库，只需把这个目录拷贝至另一处即可。以下是一个全新的Git版本库的默认结构：

``` powershell
C:\USERS\惠普\DESKTOP\TEST\.GIT
|   config
|   description
|   HEAD
|
+---hooks
|       applypatch-msg.sample
|       commit-msg.sample
|       fsmonitor-watchman.sample
|       post-update.sample
|       pre-applypatch.sample
|       pre-commit.sample
|       pre-merge-commit.sample
|       pre-push.sample
|       pre-rebase.sample
|       pre-receive.sample
|       prepare-commit-msg.sample
|       update.sample
|
+---info
|       exclude
|
+---objects
|   +---info
|   \---pack
\---refs
    +---heads
    \---tags
```

其中以下4个部分我们通常无需关心：

1. `config`文件是只针对该版本库的Git配置文件；
2. `description`文件仅供GitWeb程序使用；
3. `hooks` 目录包含客户端或者服务器端的钩子脚本(hook scripts)；
4. `info` 目录包含一个全局性排除(global exclude)文件，用以放置那些不希望被记录在 `.gitignore` 文件中的忽略模式(ignored patterns)。

以下4个部分最为重要：

1. `HEAD`文件指向当前所在的分支，即目前被检出(check out)的分支；
2. 尚未创建的`index`文件，即索引，或者也可以被称之为暂存区域；
3. `objects`目录用于存储所有的数据，即所有的对象；
4. `refs`目录存储对对象的引用，该目录包含3个子目录：`heads`、`tags`、`remotes`。

---

# Git对象

`objects`目录实质上是一个简单的键值对数据库(key-value data store)，该数据库中存储了所有的数据，即所有的对象。Git中的对象有4种：

1. blob对象，也就是二进制大对象(binary large object)，我们项目中的每一个文件都是以这种形式来存储的；
2. tree对象，也就是树对象，如果说blob对象对应于文件，那么tree对象则对应于目录；
3. commit对象，也就是提交对象，用于存储提交的相关信息；
4. tag对象，即标签对象，用于存储附注标签(而不是轻量标签)的相关信息。

Git对对象的存储遵循着以下规则：

1. Git识别出对象的类型，再计算出该对象数据内容的字节数，然后将它们拼接起来，生成头部(header)信息；
2. 将生成的头部信息(header)和原始数据(content)拼接在一起，生成待存储(store)的信息；
3. 计算待存储的信息的SHA-1校验和(checksum)，一个包含40个十六进制字符的字符串，这个校验和就是键值对数据库中的键(key)，也就是数据库中每一个数据的“唯一标识符”；
4. 利用zlib库压缩待存储的信息；
5. 在`objects`目录下新建一个子目录(如果该子目录不存在的话)，子目录的名字为40位校验和的前两个字符，再在该子目录下新建一个文件，文件名为40位校验和的后38个字符；
6. 打开新创建的文件，将压缩后的信息写到该文件中。

>注1：SHA-1全称为Secure Hash Algorithm 1，也就是安全哈希算法1，可以用来生成被称为消息摘要(digest)的哈希值，Git中使用该哈希算法来计算对象的校验和，即数据库中的数据的键值。
>注2：由于`objects`目录实质上是一个数据库，因此保证一个数据库的效率是至关重要的，事实上，Git采用了很多的方法来做到这一点，正如以上所描述的，将待存储的信息压缩后再存储，以及将对象分别存放到不同的目录中，都是为了保证数据库的效率，前者大大的减少了数据库的体积，而后者则减少了查找数据所需的时间。

所有的Git对象均以上述方式进行存储，区别仅在于类型标识——blob对象的头部信息以字符串“blob”开头，而tree对象则以“tree”开头；此外，blob对象的原始数据几乎可以是任何内容，而其它类型的对象的内容却有各自固定的格式。

以下将逐个讲解前3种对象，其中tag对象将在[Git引用](#Git引用)中进行讲解：

## blob对象

blob对象用于存储文件内容。

可以通过底层命令`git hash-object`来计算对象的SHA-1校验和，当指定`-w`选项时，Git还会将该对象写入数据库中。

对于已经存储在对象数据库中的数据，可以通过底层命令`git cat-file`从数据库中取回数据，当指定 `-p` 选项时，可指示该命令自动判断内容的类型，并为我们显示大致的内容；此外， 当为该命令指定`-t`选项时，可以让Git告诉我们其内部存储的任何对象类型，只要给定该对象的SHA-1值。

blob对象虽然能存储每一个文件的内容，但却并没有保存文件的名字，此外，直接操作blob对象意味着我们必须记住文件的每一个版本所对应的SHA-1值，这并不现实。

## tree对象

tree对象能解决文件名保存的问题，也允许我们将多个文件组织到一起。一个tree对象包含了一条或多条tree对象条目(tree entry)，每个条目含有一个blob对象或者另一个tree对象的SHA-1校验和，以及相应的模式(mode)、类型、文件名信息。

通常情况下，Git会根据某一时刻暂存区域的文件状态创建并记录一个对应的tree对象，因此，要创建一个tree对象，需要先使用底层命令`git update-index`来创建一个暂存区域(即index文件)，再通过底层命令`git write-tree` 将暂存区域的内容写入一个tree对象。

> 注1：Git中的文件模式(mode)参考了常见的UNIX文件模式，对于blob对象来说，合法的文件模式只有3个：100644代表普通文件，100755代表可执行文件，120000代表符号链接；
> 注2：你还可以通过底层命令`git read-tree`来将tree对象读入暂存区域，使之成为另一个tree对象的子树。

事实上，一个记录了某个时刻暂存区域的文件状态的tree对象就是对项目中某个时刻的文件版本的一次快照(snapshot)，而这样的tree对象正是Git版本库中的每一次提交的主干部分，可对于一次提交来说，我们不仅需要记录那个时刻的文件版本，还需要记录提交者以及提交日期等相关信息，此外，与blob对象一样，我们还是需要记忆每一个tree对象的SHA-1值。

## commit对象

事实上，我们每次运行命令`git add` 和`git commit`，Git所做的工作实质上就是如下几个步骤：

1. 将被修改的文件保存为blob对象；

2. 更新暂存区域；
3. 记录tree对象；
4. 创建一个指明了顶层tree对象和父提交的commit对象。

其中第4步可以通过底层命令`git commit-tree`来实现，该命令会创建一个commit对象，为此需要指定一个tree对象的SHA-1值、该提交的父提交对象(如果有的话)，以及提交说明。

> 注：一个提交的父提交指的是该提交在其所处的分支中的前一个提交。

一个commit对象包含的内容的格式如下：

1. 先指定一个顶层tree对象，代表该提交所记录的快照，即某个时刻的文件版本；
2. 然后是可能存在的父提交，也就是一个指向分支中上一个结点的指针；
3. 之后是作者/提交者的信息，这个将根据`user.name`和`user.email`来设定；
4. 留空一行，最后是提交说明。

以下是一个Git版本库中3种类型的对象之间的关系的实例：

![](1.png)

图中黄色的代表commit对象，蓝色的代表tree对象，白色的代表blob对象。每个commit对象都分别指向一个tree对象，并且第2/3个提交对象包含一个指向第1/2个提交对象的指针，Git以这种单向链表的方式将3个提交对象，也就是3次提交串联起来，构成了一个分支；第3个tree对象包含2个blob对象和1个tree对象的SHA-1校验和，如果此时检出(check out)第3次提交，你将会在工作树中发现两个文件`new.txt`和`test.txt`，和一个目录`bak`。

---

# Git引用

`refs`目录全称为`references`，正如该目录的名字所揭示的，该目录下存放的是指向目录`objects`中的对象的引用。`refs`目录包含3个子目录：`heads`、`tags`和`remotes`，分别存放着分支引用、标签引用和远程引用。

接下来将逐个讲解这3种引用：

## 分支引用

Git中的分支本质上是单向链表，在这个单向链表中，每一个结点都是一个commit对象，commit对象中所记录的父提交的SHA-1校验和就是指向上一个结点的指针，这样一来，只要我们知道了这个单向链表的头(head)，或者说分支的尖端(the tip of the branch)，我们就可以通过指针逐个的得到这个分支中的每一个提交记录，而`heads`就是Git用来存储Git版本库中每一个分支的头的目录。此外，出于方便，我们显然不希望使用SHA-1校验和来引用分支的头，而是更倾向于给分支的头取一个易于记忆的名字，比如`master`，这样一来，当我们需要引用分支的头，就比如切换分支时，只需要执行命令`git checkout master`，而不是`git checkout 1a4e01`这样难于记忆的命令。

当运行类似于 `git branch <branchname>` 这样的命令时，Git实际上会运行底层命令`git update-ref` ，取得当前所在分支的最新提交所对应的SHA-1值，然后在目录`.git/refs/heads/`下新建一个名字为`<branchname>`的文件，再将SHA-1校验和存储到该文件中。

现在的问题是，当你执行命令`git branch <branchname>`时，Git又是如何知道当前所在分支的最新提交所对应的SHA-1值的呢？答案是`HEAD`文件。`HEAD`文件通常是一个符号引用(symbolic reference)，指向当前所在的分支，所谓符号引用，表示它是一个指向其他引用的指针。当我们处在某个分支的尖端时，就比如`master`，此时，如果我们查看文件`HEAD`的内容，我们将会看到以下内容：

``` powershell
> cat .\.git\HEAD
ref: refs/heads/master
```

然而在某些罕见的情况下，`HEAD`文件可能会包含一个Git对象的SHA-1值。当你在检出(check out)一个标签、提交或者远程分支，让你的Git版本库变成“分离HEAD”(detached head)状态时，就会出现这种情况。

当我们在分支`<branchname>`下运行命令`git commit`时，Git会创建一个commit对象，并用`HEAD`文件中那个引用所指向的SHA-1值设置其父提交字段，然后，Git会将其存入对象数据库中，并获取该commit对象的SHA-1值，最后，再用该值替换文件`refs/heads/<branchname>`中存储的原有值。

> 注：我们可以手动编辑`HEAD`文件，但更安全的做法是使用命令`git symbolic-ref `来查看或者设置`HEAD`引用的值。

## 标签引用

Git中的标签有两种：轻量标签和附注标签。

当我们执行命令`git tag <tagname> <commit>`或者命令`git update-ref refs/tags/<tagname> <commit>`来创建一个轻量标签时，Git会在目录`.git/refs/tags/`下新建一个名为`<tagname>`的文件，并将`<commit>`所指向的commit对象的SHA-1校验和存储到该文件中，这就是一个轻量标签的全部内容——一个固定的引用。

然而，一个附注标签则更复杂一些。当我们执行命令`git tag -a -m <msg> <tagname> <commit>`来创建一个附注标签时，Git同样会在目录`.git/refs/tags/`下新建一个名为`<tagname>`的文件，但与轻量标签不一样的是，Git同时还会创建一个tag对象，并将该tag对象的SHA-1校验和写到文件`<tagname>`中，因此，附注标签中所记录的是一个指向tag对象的引用，而不是一个直接指向commit对象的引用。

tag对象类似于一个commit对象，它包含标签创建者(tagger)与标签本身的相关信息、打标签的日期、附注信息，以及一个指向我们打了标签的那个commit对象的SHA-1值。主要的区别在于，tag对象<font color="red">通常</font>指向一个commit对象，而commit对象却总是指向一个tree对象。

> 注意：tag对象并非必须指向某个commit对象，你可以对任意类型的Git对象打标签。例如，在Git源代码中，项目维护者将他们的GPG公钥添加为一个blob对象，然后对这个对象打了一个标签；Linux内核版本库同样有一个不指向commit对象的tag对象——首个被创建的tag对象所指向的是最初被引入版本库的那份内核源代码所对应的tree对象。

## 远程引用

所谓远程引用，就是我们在克隆(clone)一个远程版本库或者对某个远程版本库执行推送(push)操作时，在本地版本库中所创建的远程跟踪分支(remote-tracking branch)，它是对这一时刻的远程版本库的各分支的状态所做的一次快照，或者说，远程引用就是记录远程版本库上各分支最后已知状态的书签。

当我们执行命令`git push origin master`来将本地版本库上的`master`分支推送到远程版本库`origin`上的`master`分支时，Git会在目录`refs/remotes/origin/`下新建一个名为`master`的文件，并将本地`master`分支上的最近一次提交所对应的SHA-1值(也就是`refs/heads/master`所指向的SHA-1值)写入该文件，这就是对此刻的远程`master`分支的状态所做的一次快照。

远程引用和本地分支(即位于`refs/heads`目录下的引用)之间最主要的区别在于，远程引用是只读的。虽然我们可以通过`git checkout`来检出远程引用，但此时将处于“分离HEAD”(detached head)的状态，在这种状态下你所做的所有更改都不会被记录下来。

---

# 包文件

在目录`.git/objects/`下还有两个子目录`info`和`pack`，这两个子目录与Git的垃圾回收(garbage collect)机制有关。

Git最初向磁盘中存储对象时所使用的格式被称为“松散(loose)”对象格式，这种格式会将一个对象的所有的不同版本完整的保存下来，即使不同版本的对象之间的差异微乎其微，显然，如果此时Git只完整的保存其中一个，再保存其它对象与之前版本的差异内容，便能大大的节省数据库的空间并提高效率。事实上，Git可以这么做，不过需要满足一定的条件，当版本库中有太多的松散对象，或者你手动执行 `git gc` 命令，或者你向远程服务器执行推送操作时，就会触发Git的垃圾回收机制，Git会将数据库中的这些松散对象打包成一个被称之为“包文件(packfile)”的二进制文件。

当Git对数据库中的松散对象进行打包时，Git会查找命名及大小相近的文件，并只保存文件不同版本之间的差异内容(也就是以补丁的形式存储文件)，最后生成一个包文件(.pack)和一个索引文件(.idx)，其中包文件包含了打包时从文件系统中移除的所有对象的内容，而索引文件则包含了包文件的偏移信息，我们通过索引文件就可以快速定位任何一个指定的对象。

通过底层命令`git verify-pack`可以查看数据库中已打包的内容。值得注意的是，如果被打包的内容中包含一个文件的不同版本，不妨假设有两个文件版本，那么Git会完整的保存该文件的第二个版本，也就是最新的那个版本，而第一个版本，也就是该文件的原始版本，反而是以差异的方式进行保存的，并引用该文件的第二个版本。为什么呢？因为大部分情况下我们需要快速地访问文件的最新版本，而不是较原始的版本。

> 注：Git并不会打包所有的对象。对于未被任何提交记录引用的对象，Git会认为它们是悬空(dangling)的，因而不会选择将它们打包进包文件中。什么时候对象数据库中会出现悬空的对象呢？其中一种情况是，当某个对象只被一个分支上的提交记录唯一地引用时，若我们此时删除这个分支，那么目录`refs/heads/`下的对应的引用将会被删除，但是我们在这个分支上所创建的所有对象依然存在，因而随着这个分支的删除，这些对象也就成为了悬空的对象。
